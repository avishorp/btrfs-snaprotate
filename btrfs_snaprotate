#!/usr/bin/env python

import getopt, sys
import os, os.path
import subprocess
import logging, re

usage = """
   btrfs-snaprotate [-l|--label=label] [-k|--keep=num] [-a|--after=command] [--dry-run]
                    [-t|--target=dir] [--log=logspec] [-v] subvolume

     subvolume - The subvolume to snapshot
     --label - The prefix of the name of the snapshot. Every snapshot will be named label_YYYY_MM_DD_hh:mm:ss.
               The default prefix is the name of the last component in the path of the subvolume being snapshot,
               or root for root snapshots.
     --keep - Number of most recent snapshots to keep.
     --after - A command to run after the snapshot was taken. The command will be run under the default shell.
               It will have the following environment variables defined:
               SNAPSUBVOL - The subvolume that was snapshot
               SNAPTARGET - The directory in which the snapshots are stored
               SNAPRECENT - The most recent snapshot

     --target - The directory in which the snapshots are stored (mounted). Defaults to <subvolume>/.snapshot.
                Must reside inside the volume being snapshot.
     -v - Verbose output
"""

default_options = {
  "label": None,       # Dynamically determined
  "keep": 7,
  "after": None,
  "dry": False,
  "target": ".snapshot",
  "log": "TBD",
  "subvolume": None,
  "verbose": False
}


class OptionsError(Exception):
  def __init__(self, message):
    super(OptionsError, self).__init__(message)

class BTRFSExecutionError(RuntimeError):
    def __init__(self, ec, stdout, stderr):
        super(BTRFSExecutionError, self).__init__("BTRFS Execution failed")
        self.ec = ec
        self.stdout = stdout
        self.stderr = stderr

class btrfs_util:
  BTRFS_UTIL_EXE_NAME = "btrfs"

  def __init__(self, btrfs_exe = None):
    if btrfs_exe is not None:
      self.btrfs_exe = btrfs_exe
    else:
      self.btrfs_exe = self.which(self.BTRFS_UTIL_EXE_NAME)

    if self.btrfs_exe is None:
        raise RuntimeError("Could not find btrfs executable")

  def which(self, exename):
    # Find the an executable in the path
    for path in os.environ["PATH"].split(os.pathsep):
      path = path.strip('"')
      exe = os.path.join(path, exename)
      if os.path.isfile(exe) and os.access(exe, os.X_OK):
        return exe

    # Not found
    return None

  def exec_btrfs_util(self, arguments):
    cmd = [self.btrfs_exe] + arguments
    logging.debug('Executing: ' + ' '.join(cmd))
    btrfs_proc = subprocess.Popen([self.btrfs_exe] + arguments,
        stdout = subprocess.PIPE, stderr = subprocess.PIPE)
    (stdout, stderr) = btrfs_proc.communicate()
    logging.debug('btrfs finised with return code %d' % btrfs_proc.returncode)

    return (btrfs_proc.returncode, stdout, stderr)

  def create_snapshot(self, subvol, dest):
    pass

  def delete_snapshot(self, snapname):
    pass

  def validate_is_btrfs(self, dir):
    pass

  def btrfs_util_version(self):
      # Exepect a return string looking like this
      ver_string = re.compile(r"btrfs-progs v([0-9]+\.[0-9]+)")

      # Execute btrfs to get the version
      ec, stdout, stderr = self.exec_btrfs_util(['version'])

      # Check the return code and the version string
      if ec != 0:
          # Problem executing the util
          raise BTRFSExecutionError(ec, stdout, stderr)

      v = ver_string.match(stdout)
      if v is None:
          # Malformed version string
          raise BTRFSExecutionError(ec, stdout, stderr)

      # This is the version extracted
      return v.groups()[0]


def parse_command_line(args):
  short_options = "l:k:a:t:v"
  long_options = [ "label=", "keep=", "after=", "dry-run", "target=", "log=" ]

  # Parse the command line
  try:
    opts, pargs = getopt.getopt(args, short_options, long_options)
  except getopt.GetoptError as err:
    raise OptionsError(str(err))

  options = default_options.copy()
  for op, value in opts:
    if op in ("-l", "--label"):
	options["label"] = value

    elif op in ("-k", "--keep"):
      try:
        options["keep"] = int(value)
        if (options["keep"] < 1) or (options["keep"] > 500):
          raise ValueError()
      except ValueError:
        raise OptionsError("Keep value must be an integer between 1-500")

    elif op in ("-a", "--after"):
      options["after"] = value

    elif op == "--dry-run":
      options["dry"] = True

    elif op in ("-t", "--target"):
      options["target"] = value

    elif op == "-v":
       options["verbose"] = True

  # Handle the (single) positional argument
  if len(pargs) != 1:
    raise OptionsError("Must specify exactly one subvolume to snapshot")
  options["subvolume"] = pargs[0]

  if options["verbose"]:
    logging.getLogger().setLevel(logging.DEBUG)

  logging.debug("Exec arguments: Subvolume = %s" % options["subvolume"])
  logging.debug("Exec arguments: Label = %s" % options["label"])
  logging.debug("Exec arguments: Keep = %d" % options["keep"])
  if options["after"] is not None:
      logging.debug("Exec arguments: Keep = %s" % options["after"])
  logging.debug("Exec arguments: Dry Run = %s" % ("Yes" if options["dry"] else "No"))
  logging.debug("Exec arguments: Target = %s" % options["target"])

  return options

#####
##### Main
#####
if __name__ == "__main__":
  # Set up logger
  logging.basicConfig(format = "%(asctime)s [%(levelname)s] %(message)s")

  try:
    options = parse_command_line(sys.argv[1:])
  except OptionsError as err:
    logging.critical(str(err))
    sys.stderr.write(usage)
    sys.exit(1)

  try:
      # Check that the given subvolume is a btrfs subvolume
      btrfs = btrfs_util()
      btrfs_ver = btrfs.btrfs_util_version()
      logging.debug("btrfs version: %s" % btrfs_ver)

  except BTRFSExecutionError, e:
      logging.critical(e.message)
      logging.critical("  btrfs exited with %d" % e.ec)
      logging.critical("  stdout:")
      for l in e.stdout.split('\n'):
          logging.critical("  | " + l)
      logging.critical("  stderr:")
      for l in e.stderr.split('\n'):
          logging.critical("  | " + l)


  except RuntimeError, e:
      logging.critical(e.message)
