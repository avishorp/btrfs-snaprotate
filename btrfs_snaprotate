#!/usr/bin/env python

import getopt, sys
import os, os.path
import subprocess
import logging, re
from dateutil import parser
import time

usage = """
   btrfs-snaprotate [-l|--label=label] [-k|--keep=num] [-a|--after=command] [--dry-run]
                    [-t|--target=dir] [--log=logspec] [-v] subvolume

     subvolume - The subvolume to snapshot
     --label - The prefix of the name of the snapshot. Every snapshot will be named label_YYYY_MM_DD_hh:mm:ss.
               The default prefix is the name of the last component in the path of the subvolume being snapshot,
               or root for root snapshots.
     --keep - Number of most recent snapshots to keep.
     --after - A command to run after the snapshot was taken. The command will be run under the default shell.
               It will have the following environment variables defined:
               SNAPSUBVOL - The subvolume that was snapshot
               SNAPTARGET - The directory in which the snapshots are stored
               SNAPRECENT - The most recent snapshot

     --target - The directory in which the snapshots are stored (mounted). Defaults to <subvolume>/.snapshot.
                Must reside inside the volume being snapshot.
     -v - Verbose output
"""

default_options = {
  "label": None,       # Dynamically determined
  "keep": 7,
  "after": None,
  "dry": False,
  "target": ".snapshot",
  "log": "TBD",
  "subvolume": None,
  "verbose": False
}

# Regular expression used to check the label validity
label_rx = re.compile(r"[a-zA-Z][a-zA-Z0-9_\-]*$")


class OptionsError(Exception):
  def __init__(self, message):
    super(OptionsError, self).__init__(message)

class BTRFSExecutionError(RuntimeError):
    def __init__(self, ec, stdout, stderr):
        super(BTRFSExecutionError, self).__init__("BTRFS Execution failed")
        self.ec = ec
        self.stdout = stdout
        self.stderr = stderr

class btrfs_util:
  BTRFS_UTIL_EXE_NAME = "btrfs"

  def __init__(self, btrfs_exe = None):
    if btrfs_exe is not None:
      self.btrfs_exe = btrfs_exe
    else:
      self.btrfs_exe = self.which(self.BTRFS_UTIL_EXE_NAME)

    if self.btrfs_exe is None:
        raise RuntimeError("Could not find btrfs executable")

    # Used to decode "subvolume show" command results
    self.show_regex = re.compile(r"([a-zA-Z ()]+):\s*([^\s].*)")

  def which(self, exename):
    # Find the an executable in the path
    for path in os.environ["PATH"].split(os.pathsep):
      path = path.strip('"')
      exe = os.path.join(path, exename)
      if os.path.isfile(exe) and os.access(exe, os.X_OK):
        return exe

    # Not found
    return None

  def exec_btrfs_util(self, arguments):
    cmd = [self.btrfs_exe] + arguments
    logging.debug('Executing: ' + ' '.join(cmd))
    btrfs_proc = subprocess.Popen([self.btrfs_exe] + arguments,
        stdout = subprocess.PIPE, stderr = subprocess.PIPE)
    (stdout, stderr) = btrfs_proc.communicate()
    logging.debug('btrfs finised with return code %d' % btrfs_proc.returncode)

    return (btrfs_proc.returncode, stdout, stderr)

  def create_snapshot(self, subvol, dest):
      ec, stdout, stderr = self.exec_btrfs_util(['subvolume', 'snapshot', subvol, dest])
      if ec != 0:
          # Problem executing the util
          raise BTRFSExecutionError(ec, stdout, stderr)

  def delete_snapshot(self, snapname):
      ec, stdout, stderr = self.exec_btrfs_util(['subvolume', 'delete', 'snapname'])
      if ec != 0:
          # Problem executing the util
          raise BTRFSExecutionError(ec, stdout, stderr)

  def list_subvolumes(self, pathname):
    ec, stdout, stderr = self.exec_btrfs_util(['subvolume', 'list', pathname])
    if (ec != 0):
          # Problem executing the util
          raise BTRFSExecutionError(ec, stdout, stderr)

    subvols = []
    for l in stdout.split('\n'):
        # The subvolume path is the 9th field
        fss = l.split(' ')
        if ((len(fss) >= 9) and (fss[7] == 'path')):
            subvols.append(fss[8])

    return subvols

  def show_subvolume(self, pathname):
    ec, stdout, stderr = self.exec_btrfs_util(['subvolume', 'show', pathname])
    if (ec != 0):
          # Problem executing the util
          raise BTRFSExecutionError(ec, stdout, stderr)

    # Convert the command output into key-data pairs
    info = {}
    for l in stdout.split('\n'):
        m = self.show_regex.match(l.strip())
        if m is not None:
            key = m.groups()[0]
            value = m.groups()[1]
            info[key] = value

    return info

  def is_btrfs(self, pathname):
    ec, stdout, stderr = self.exec_btrfs_util(['subvolume', 'list', pathname])
    return (ec == 0)

  def btrfs_util_version(self):
      # Exepect a return string looking like this
      ver_string = re.compile(r"btrfs-progs v([0-9]+\.[0-9]+)")

      # Execute btrfs to get the version
      ec, stdout, stderr = self.exec_btrfs_util(['version'])

      # Check the return code and the version string
      if ec != 0:
          # Problem executing the util
          raise BTRFSExecutionError(ec, stdout, stderr)

      v = ver_string.match(stdout)
      if v is None:
          # Malformed version string
          raise BTRFSExecutionError(ec, stdout, stderr)

      # This is the version extracted
      return v.groups()[0]

##
## Utility Functions
##

def parse_command_line(args):
  short_options = "l:k:a:t:v"
  long_options = [ "label=", "keep=", "after=", "dry-run", "target=", "log=" ]

  # Parse the command line
  try:
    opts, pargs = getopt.getopt(args, short_options, long_options)
  except getopt.GetoptError as err:
    raise OptionsError(str(err))

  options = default_options.copy()
  for op, value in opts:
    if op in ("-l", "--label"):
        if (label_rx.match(value) is None):
            raise OptionsError("Invalid label")
        options["label"] = value

    elif op in ("-k", "--keep"):
      try:
        options["keep"] = int(value)
        if (options["keep"] < 1) or (options["keep"] > 500):
          raise ValueError()
      except ValueError:
        raise OptionsError("Keep value must be an integer between 1-500")

    elif op in ("-a", "--after"):
      options["after"] = value

    elif op == "--dry-run":
      options["dry"] = True

    elif op in ("-t", "--target"):
      options["target"] = value

    elif op == "-v":
       options["verbose"] = True

  # Handle the (single) positional argument
  if len(pargs) != 1:
    raise OptionsError("Must specify exactly one subvolume to snapshot")
  options["subvolume"] = pargs[0]

  if options["verbose"]:
    logging.getLogger().setLevel(logging.DEBUG)

  logging.debug("Exec arguments: Subvolume = %s" % options["subvolume"])
  logging.debug("Exec arguments: Label = %s" % options["label"])
  logging.debug("Exec arguments: Keep = %d" % options["keep"])
  if options["after"] is not None:
      logging.debug("Exec arguments: Keep = %s" % options["after"])
  logging.debug("Exec arguments: Dry Run = %s" % ("Yes" if options["dry"] else "No"))
  logging.debug("Exec arguments: Target = %s" % options["target"])

  return options

def snapshot_filename(target, label):
    now = time.strftime("%Y-%m-%d_%H:%M:%S")
    return os.path.join(target, label + '_' + now)

#####
##### Main
#####
if __name__ == "__main__":
  # Set up logger
  logging.basicConfig(format = "%(asctime)s [%(levelname)s] %(message)s")

  try:
    options = parse_command_line(sys.argv[1:])
  except OptionsError as err:
    logging.critical(str(err))
    sys.stderr.write(usage)
    sys.exit(1)

  # If no label was specified, determine it from the target path
  if options["label"] is None:
      ll = os.path.split(options["subvolume"].rstrip("/"))[1]
      if ll == '':
          ll = 'root'

      options["label"] = ll

  try:
      # Read btrfs version
      btrfs = btrfs_util()
      btrfs_ver = btrfs.btrfs_util_version()
      logging.debug("btrfs version: %s" % btrfs_ver)

      # Check that the given subvolume is a btrfs subvolume
      if (not btrfs.is_btrfs(options["subvolume"])):
          logging.error("Directory %s is not a btrfs subvolume" % options["subvolume"])
          sys.exit(1)
      else:
          logging.debug("Directory %s is a btrfs volume")

      # Check that the target direcotry exists, or create it
      target_dir = os.path.join(options["subvolume"], options["target"])
      logging.debug("Target directory: " + target_dir)
      if (not os.path.isdir(target_dir)):
          logging.debug("Target directory does not exist, trying to create")
          try:
              os.mkdir(target_dir)
          except OSError, e:
              logging.error("Target directory creation failed: [%d] %s" % (e.errno, e.strerror))
              sys.exit(1)

       # Create the snapshot
      logging.info("Creating snapshot of %s" % options["subvolume"])
      btrfs.create_snapshot(options["subvolume"], snapshot_filename(target_dir, options["label"]))

      # List all the snapshots under the target directory
      all_subvolumes = btrfs.list_subvolumes(options["subvolume"])
      # Filter only those who are under the target firectory and their name starts
      # with out label
      subvolumes = filter(lambda p: p.startswith(options['target']+'/'+options['label']), all_subvolumes)
      # Retrieve the creation time of each snapshot
      subvolume_time = []
      for sbv in subvolumes:
          info = btrfs.show_subvolume(os.path.join(options["subvolume"], sbv))
          logging.debug('Found subvolume %s with creation time %s' % (sbv, info['Creation time']))
          ctm = parser.parse(info['Creation time'])
          # Convert to linear time
          ltm = ctm.toordinal() + ((1.0/24)*ctm.hour) + ((1.0/(24*60)*ctm.minute)) + ((1.0/(24*60*60)*ctm.second))
          subvolume_time.append((sbv, ltm))

      # Sort the subvolume by acending creation time
      sbvs = sorted(subvolume_time, key=lambda item: item[1])

      # Keep only "keep" ones
      if len(sbvs) > options["keep"]:
          sbv_delete = map(lambda m: m[0], sbvs[0:-options["keep"]])

          for sbv in sbv_delete:
          print sb_delete




      # Delete the oldest ones


  except BTRFSExecutionError, e:
      logging.critical(e.message)
      logging.critical("  btrfs exited with %d" % e.ec)
      logging.critical("  stdout:")
      for l in e.stdout.split('\n'):
          logging.critical("  | " + l)
      logging.critical("  stderr:")
      for l in e.stderr.split('\n'):
          logging.critical("  | " + l)


  except RuntimeError, e:
      logging.critical(e.message)
